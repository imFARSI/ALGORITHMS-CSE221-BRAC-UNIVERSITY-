# -*- coding: utf-8 -*-
"""CSE221 LAB 05.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-kvuUc-b_s6xqb9i5aYyqa0Ea8qRdN33
"""

#task 1
a,b=map(int,input().split())
c=[]
d=0
while d<a+1:
	c.append([])
	d+=1
e=0
while e<b:
	f,g=map(int,input().split())
	c[f].append(g)
	c[g].append(f)
	e+=1
h=[0]*(a+1)
i=[1]
h[1]=1
j=0
while j<len(i):
	k=i[j]
	j+=1
	l=0
	while l<len(c[k]):
		m=c[k][l]
		if h[m]==0:
			h[m]=1
			i.append(m)
		l+=1
print(*i)

#TASK 2
import sys
sys.setrecursionlimit(2*100000+5)
def t(g,s,v,o):
    v[s]=True
    o.append(s)
    for n in sorted(g[s]):
        if not v[n]:
            t(g,n,v,o)
n,m=map(int,input().split())
g=[[]for _ in range(n+1)]
x=list(map(int,input().split()))
y=list(map(int,input().split()))
for i in range(m):
    g[x[i]].append(y[i])
    g[y[i]].append(x[i])
v=[False]*(n+1)
o=[]
t(g,1,v,o)
print(*o)

#task 3
n,m,s,d=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
g=[[]for _ in range(n+1)]
for i in range(m):
    g[a[i]].append(b[i])
    g[b[i]].append(a[i])
for i in range(1,n+1):
    g[i].sort()
v=[0]*(n+1)
p=[-1]*(n+1)
q=[0]*n*2
f=0
r=0
q[r]=s
r+=1
v[s]=1
while f<r:
    x=q[f]
    f+=1
    if x==d:
        break
    for y in g[x]:
        if v[y]==0:
            v[y]=1
            p[y]=x
            q[r]=y
            r+=1
if v[d]==0:
    print(-1)
else:
    path=[]
    while d!=-1:
        path.append(d)
        d=p[d]
    path.reverse()
    print(len(path)-1)
    print(*path)

"""8 7 3 2
7 7 3 2 2 8 5
2 6 7 4 1 4 1
"""

#task 4
n,m,s,d,k=map(int,input().split())
adj=[[]for i in range(n+1)]
for _ in range(m):
    a,b=map(int,input().split())
    adj[a].append(b)
def bfs(start):
    mark=[0]*(n+1)
    prev=[-1]*(n+1)
    q=[0]*n*2
    l=0
    r=0
    q[r]= start
    r+=1
    mark[start]=1
    while l<r:
        cur=q[l]
        l+=1
        for nex in adj[cur]:
            if mark[nex]==0:
                mark[nex]=1
                prev[nex]=cur
                q[r]=nex
                r+=1
    return mark,prev
m1,p1 =bfs(s)
m2,p2=bfs(k)
if m1[k]==0 or m2[d]==0:
    print(-1)
else:
    res= []
    t=k
    while t!=-1:
        res.append(t)
        t=p1[t]
    res.reverse()
    t=d
    tmp =[]
    while t!=-1:
        tmp.append(t)
        t=p2[t]
    tmp.reverse()
    for i in range(1,len(tmp)):
        res.append(tmp[i])
    print(len(res)-1)
    print(*res)

#tasjk 5
a,b=map(int,input().split())
z=[[]for _ in range(a+1)]
for i in range(b):
    p,q=map(int,input().split())
    z[p].append(q)
s=[0]*(a+1)
def f(x):
    s[x]=1
    for y in z[x]:
        if s[y]==0:
            if f(y):
                return 1
        elif s[y]==1:
            return 1
    s[x]=2
    return 0
r=0
for i in range(1,a+1):
    if s[i]==0:
        if f(i):
            r=1
            break
if r:
    print("YES")
else:
    print("NO")

#task 6
import sys
sys.setrecursionlimit(10**7)
r,c=map(int,input().split())
g=[list(input())for _ in range(r)]
v=[[0]*c for i in range(r)]
dx=[-1,1,0,0]
dy=[0,0,-1,1]
def dfs(x,y):
    v[x][y]=1
    cnt=1 if g[x][y]=='D' else 0
    for i in range(4):
        nx=x+dx[i]
        ny=y+dy[i]
        if 0<=nx<r and 0<=ny<c:
            if g[nx][ny]!='#' and v[nx][ny]==0:
                cnt+=dfs(nx,ny)
    return cnt
ans=0
for i in range(r):
    for j in range(c):
        if g[i][j]!='#' and v[i][j]==0:
            ans=max(ans,dfs(i,j))
print(ans)

import sys
sys.setrecursionlimit(10**7)
x,y= map(int,input().split())
z = [list(input())for i in range(x)]
b = [[0]*y for j in range(x)]
p = [-1,1,0,0]
q = [0,0,-1,1]
def k(i,j):
    b[i][j]=1
    s = 1 if z[i][j] == 'D'else 0
    for t in range(4):
        ni = i+p[t]
        nj = j+q[t]
        if 0<=ni<x and 0<=nj<y:
            if z[ni][nj]! = '#':
                if b[ni][nj] == 0:
                    s+=k(ni,nj)
    return s
w=0
for i in range(x):
    for j in range(y):
        if z[i][j]!='#':
            if b[i][j]==0:
                r = k(i,j)
                if r>w:
                    w = r
print(w)
